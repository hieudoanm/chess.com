/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck
/*
 * This file exports various common sort, input & filter types that are not directly linked to a particular model.
 *
 * ðŸŸ¢ You can import this file directly.
 */

import type * as runtime from '@prisma/client/runtime/client';
import * as $Enums from './enums';
import type * as Prisma from './internal/prismaNamespace';

export type IntFilter<$PrismaModel = never> = {
	equals?: number | Prisma.IntFieldRefInput<$PrismaModel>;
	in?: number[];
	notIn?: number[];
	lt?: number | Prisma.IntFieldRefInput<$PrismaModel>;
	lte?: number | Prisma.IntFieldRefInput<$PrismaModel>;
	gt?: number | Prisma.IntFieldRefInput<$PrismaModel>;
	gte?: number | Prisma.IntFieldRefInput<$PrismaModel>;
	not?: Prisma.NestedIntFilter<$PrismaModel> | number;
};

export type StringFilter<$PrismaModel = never> = {
	equals?: string | Prisma.StringFieldRefInput<$PrismaModel>;
	in?: string[];
	notIn?: string[];
	lt?: string | Prisma.StringFieldRefInput<$PrismaModel>;
	lte?: string | Prisma.StringFieldRefInput<$PrismaModel>;
	gt?: string | Prisma.StringFieldRefInput<$PrismaModel>;
	gte?: string | Prisma.StringFieldRefInput<$PrismaModel>;
	contains?: string | Prisma.StringFieldRefInput<$PrismaModel>;
	startsWith?: string | Prisma.StringFieldRefInput<$PrismaModel>;
	endsWith?: string | Prisma.StringFieldRefInput<$PrismaModel>;
	not?: Prisma.NestedStringFilter<$PrismaModel> | string;
};

export type EnumTitleFilter<$PrismaModel = never> = {
	equals?: $Enums.Title | Prisma.EnumTitleFieldRefInput<$PrismaModel>;
	in?: $Enums.Title[];
	notIn?: $Enums.Title[];
	not?: Prisma.NestedEnumTitleFilter<$PrismaModel> | $Enums.Title;
};

export type BoolFilter<$PrismaModel = never> = {
	equals?: boolean | Prisma.BooleanFieldRefInput<$PrismaModel>;
	not?: Prisma.NestedBoolFilter<$PrismaModel> | boolean;
};

export type DateTimeFilter<$PrismaModel = never> = {
	equals?: Date | string | Prisma.DateTimeFieldRefInput<$PrismaModel>;
	in?: Date[] | string[];
	notIn?: Date[] | string[];
	lt?: Date | string | Prisma.DateTimeFieldRefInput<$PrismaModel>;
	lte?: Date | string | Prisma.DateTimeFieldRefInput<$PrismaModel>;
	gt?: Date | string | Prisma.DateTimeFieldRefInput<$PrismaModel>;
	gte?: Date | string | Prisma.DateTimeFieldRefInput<$PrismaModel>;
	not?: Prisma.NestedDateTimeFilter<$PrismaModel> | Date | string;
};

export type IntWithAggregatesFilter<$PrismaModel = never> = {
	equals?: number | Prisma.IntFieldRefInput<$PrismaModel>;
	in?: number[];
	notIn?: number[];
	lt?: number | Prisma.IntFieldRefInput<$PrismaModel>;
	lte?: number | Prisma.IntFieldRefInput<$PrismaModel>;
	gt?: number | Prisma.IntFieldRefInput<$PrismaModel>;
	gte?: number | Prisma.IntFieldRefInput<$PrismaModel>;
	not?: Prisma.NestedIntWithAggregatesFilter<$PrismaModel> | number;
	_count?: Prisma.NestedIntFilter<$PrismaModel>;
	_avg?: Prisma.NestedFloatFilter<$PrismaModel>;
	_sum?: Prisma.NestedIntFilter<$PrismaModel>;
	_min?: Prisma.NestedIntFilter<$PrismaModel>;
	_max?: Prisma.NestedIntFilter<$PrismaModel>;
};

export type StringWithAggregatesFilter<$PrismaModel = never> = {
	equals?: string | Prisma.StringFieldRefInput<$PrismaModel>;
	in?: string[];
	notIn?: string[];
	lt?: string | Prisma.StringFieldRefInput<$PrismaModel>;
	lte?: string | Prisma.StringFieldRefInput<$PrismaModel>;
	gt?: string | Prisma.StringFieldRefInput<$PrismaModel>;
	gte?: string | Prisma.StringFieldRefInput<$PrismaModel>;
	contains?: string | Prisma.StringFieldRefInput<$PrismaModel>;
	startsWith?: string | Prisma.StringFieldRefInput<$PrismaModel>;
	endsWith?: string | Prisma.StringFieldRefInput<$PrismaModel>;
	not?: Prisma.NestedStringWithAggregatesFilter<$PrismaModel> | string;
	_count?: Prisma.NestedIntFilter<$PrismaModel>;
	_min?: Prisma.NestedStringFilter<$PrismaModel>;
	_max?: Prisma.NestedStringFilter<$PrismaModel>;
};

export type EnumTitleWithAggregatesFilter<$PrismaModel = never> = {
	equals?: $Enums.Title | Prisma.EnumTitleFieldRefInput<$PrismaModel>;
	in?: $Enums.Title[];
	notIn?: $Enums.Title[];
	not?: Prisma.NestedEnumTitleWithAggregatesFilter<$PrismaModel> | $Enums.Title;
	_count?: Prisma.NestedIntFilter<$PrismaModel>;
	_min?: Prisma.NestedEnumTitleFilter<$PrismaModel>;
	_max?: Prisma.NestedEnumTitleFilter<$PrismaModel>;
};

export type BoolWithAggregatesFilter<$PrismaModel = never> = {
	equals?: boolean | Prisma.BooleanFieldRefInput<$PrismaModel>;
	not?: Prisma.NestedBoolWithAggregatesFilter<$PrismaModel> | boolean;
	_count?: Prisma.NestedIntFilter<$PrismaModel>;
	_min?: Prisma.NestedBoolFilter<$PrismaModel>;
	_max?: Prisma.NestedBoolFilter<$PrismaModel>;
};

export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
	equals?: Date | string | Prisma.DateTimeFieldRefInput<$PrismaModel>;
	in?: Date[] | string[];
	notIn?: Date[] | string[];
	lt?: Date | string | Prisma.DateTimeFieldRefInput<$PrismaModel>;
	lte?: Date | string | Prisma.DateTimeFieldRefInput<$PrismaModel>;
	gt?: Date | string | Prisma.DateTimeFieldRefInput<$PrismaModel>;
	gte?: Date | string | Prisma.DateTimeFieldRefInput<$PrismaModel>;
	not?: Prisma.NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string;
	_count?: Prisma.NestedIntFilter<$PrismaModel>;
	_min?: Prisma.NestedDateTimeFilter<$PrismaModel>;
	_max?: Prisma.NestedDateTimeFilter<$PrismaModel>;
};

export type EnumTimeClassFilter<$PrismaModel = never> = {
	equals?: $Enums.TimeClass | Prisma.EnumTimeClassFieldRefInput<$PrismaModel>;
	in?: $Enums.TimeClass[];
	notIn?: $Enums.TimeClass[];
	not?: Prisma.NestedEnumTimeClassFilter<$PrismaModel> | $Enums.TimeClass;
};

export type EnumVariantFilter<$PrismaModel = never> = {
	equals?: $Enums.Variant | Prisma.EnumVariantFieldRefInput<$PrismaModel>;
	in?: $Enums.Variant[];
	notIn?: $Enums.Variant[];
	not?: Prisma.NestedEnumVariantFilter<$PrismaModel> | $Enums.Variant;
};

export type FloatFilter<$PrismaModel = never> = {
	equals?: number | Prisma.FloatFieldRefInput<$PrismaModel>;
	in?: number[];
	notIn?: number[];
	lt?: number | Prisma.FloatFieldRefInput<$PrismaModel>;
	lte?: number | Prisma.FloatFieldRefInput<$PrismaModel>;
	gt?: number | Prisma.FloatFieldRefInput<$PrismaModel>;
	gte?: number | Prisma.FloatFieldRefInput<$PrismaModel>;
	not?: Prisma.NestedFloatFilter<$PrismaModel> | number;
};

export type EnumResultFilter<$PrismaModel = never> = {
	equals?: $Enums.Result | Prisma.EnumResultFieldRefInput<$PrismaModel>;
	in?: $Enums.Result[];
	notIn?: $Enums.Result[];
	not?: Prisma.NestedEnumResultFilter<$PrismaModel> | $Enums.Result;
};

export type EnumPhraseFilter<$PrismaModel = never> = {
	equals?: $Enums.Phrase | Prisma.EnumPhraseFieldRefInput<$PrismaModel>;
	in?: $Enums.Phrase[];
	notIn?: $Enums.Phrase[];
	not?: Prisma.NestedEnumPhraseFilter<$PrismaModel> | $Enums.Phrase;
};

export type EnumTimeClassWithAggregatesFilter<$PrismaModel = never> = {
	equals?: $Enums.TimeClass | Prisma.EnumTimeClassFieldRefInput<$PrismaModel>;
	in?: $Enums.TimeClass[];
	notIn?: $Enums.TimeClass[];
	not?:
		| Prisma.NestedEnumTimeClassWithAggregatesFilter<$PrismaModel>
		| $Enums.TimeClass;
	_count?: Prisma.NestedIntFilter<$PrismaModel>;
	_min?: Prisma.NestedEnumTimeClassFilter<$PrismaModel>;
	_max?: Prisma.NestedEnumTimeClassFilter<$PrismaModel>;
};

export type EnumVariantWithAggregatesFilter<$PrismaModel = never> = {
	equals?: $Enums.Variant | Prisma.EnumVariantFieldRefInput<$PrismaModel>;
	in?: $Enums.Variant[];
	notIn?: $Enums.Variant[];
	not?:
		| Prisma.NestedEnumVariantWithAggregatesFilter<$PrismaModel>
		| $Enums.Variant;
	_count?: Prisma.NestedIntFilter<$PrismaModel>;
	_min?: Prisma.NestedEnumVariantFilter<$PrismaModel>;
	_max?: Prisma.NestedEnumVariantFilter<$PrismaModel>;
};

export type FloatWithAggregatesFilter<$PrismaModel = never> = {
	equals?: number | Prisma.FloatFieldRefInput<$PrismaModel>;
	in?: number[];
	notIn?: number[];
	lt?: number | Prisma.FloatFieldRefInput<$PrismaModel>;
	lte?: number | Prisma.FloatFieldRefInput<$PrismaModel>;
	gt?: number | Prisma.FloatFieldRefInput<$PrismaModel>;
	gte?: number | Prisma.FloatFieldRefInput<$PrismaModel>;
	not?: Prisma.NestedFloatWithAggregatesFilter<$PrismaModel> | number;
	_count?: Prisma.NestedIntFilter<$PrismaModel>;
	_avg?: Prisma.NestedFloatFilter<$PrismaModel>;
	_sum?: Prisma.NestedFloatFilter<$PrismaModel>;
	_min?: Prisma.NestedFloatFilter<$PrismaModel>;
	_max?: Prisma.NestedFloatFilter<$PrismaModel>;
};

export type EnumResultWithAggregatesFilter<$PrismaModel = never> = {
	equals?: $Enums.Result | Prisma.EnumResultFieldRefInput<$PrismaModel>;
	in?: $Enums.Result[];
	notIn?: $Enums.Result[];
	not?:
		| Prisma.NestedEnumResultWithAggregatesFilter<$PrismaModel>
		| $Enums.Result;
	_count?: Prisma.NestedIntFilter<$PrismaModel>;
	_min?: Prisma.NestedEnumResultFilter<$PrismaModel>;
	_max?: Prisma.NestedEnumResultFilter<$PrismaModel>;
};

export type EnumPhraseWithAggregatesFilter<$PrismaModel = never> = {
	equals?: $Enums.Phrase | Prisma.EnumPhraseFieldRefInput<$PrismaModel>;
	in?: $Enums.Phrase[];
	notIn?: $Enums.Phrase[];
	not?:
		| Prisma.NestedEnumPhraseWithAggregatesFilter<$PrismaModel>
		| $Enums.Phrase;
	_count?: Prisma.NestedIntFilter<$PrismaModel>;
	_min?: Prisma.NestedEnumPhraseFilter<$PrismaModel>;
	_max?: Prisma.NestedEnumPhraseFilter<$PrismaModel>;
};

export type NestedIntFilter<$PrismaModel = never> = {
	equals?: number | Prisma.IntFieldRefInput<$PrismaModel>;
	in?: number[];
	notIn?: number[];
	lt?: number | Prisma.IntFieldRefInput<$PrismaModel>;
	lte?: number | Prisma.IntFieldRefInput<$PrismaModel>;
	gt?: number | Prisma.IntFieldRefInput<$PrismaModel>;
	gte?: number | Prisma.IntFieldRefInput<$PrismaModel>;
	not?: Prisma.NestedIntFilter<$PrismaModel> | number;
};

export type NestedStringFilter<$PrismaModel = never> = {
	equals?: string | Prisma.StringFieldRefInput<$PrismaModel>;
	in?: string[];
	notIn?: string[];
	lt?: string | Prisma.StringFieldRefInput<$PrismaModel>;
	lte?: string | Prisma.StringFieldRefInput<$PrismaModel>;
	gt?: string | Prisma.StringFieldRefInput<$PrismaModel>;
	gte?: string | Prisma.StringFieldRefInput<$PrismaModel>;
	contains?: string | Prisma.StringFieldRefInput<$PrismaModel>;
	startsWith?: string | Prisma.StringFieldRefInput<$PrismaModel>;
	endsWith?: string | Prisma.StringFieldRefInput<$PrismaModel>;
	not?: Prisma.NestedStringFilter<$PrismaModel> | string;
};

export type NestedEnumTitleFilter<$PrismaModel = never> = {
	equals?: $Enums.Title | Prisma.EnumTitleFieldRefInput<$PrismaModel>;
	in?: $Enums.Title[];
	notIn?: $Enums.Title[];
	not?: Prisma.NestedEnumTitleFilter<$PrismaModel> | $Enums.Title;
};

export type NestedBoolFilter<$PrismaModel = never> = {
	equals?: boolean | Prisma.BooleanFieldRefInput<$PrismaModel>;
	not?: Prisma.NestedBoolFilter<$PrismaModel> | boolean;
};

export type NestedDateTimeFilter<$PrismaModel = never> = {
	equals?: Date | string | Prisma.DateTimeFieldRefInput<$PrismaModel>;
	in?: Date[] | string[];
	notIn?: Date[] | string[];
	lt?: Date | string | Prisma.DateTimeFieldRefInput<$PrismaModel>;
	lte?: Date | string | Prisma.DateTimeFieldRefInput<$PrismaModel>;
	gt?: Date | string | Prisma.DateTimeFieldRefInput<$PrismaModel>;
	gte?: Date | string | Prisma.DateTimeFieldRefInput<$PrismaModel>;
	not?: Prisma.NestedDateTimeFilter<$PrismaModel> | Date | string;
};

export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
	equals?: number | Prisma.IntFieldRefInput<$PrismaModel>;
	in?: number[];
	notIn?: number[];
	lt?: number | Prisma.IntFieldRefInput<$PrismaModel>;
	lte?: number | Prisma.IntFieldRefInput<$PrismaModel>;
	gt?: number | Prisma.IntFieldRefInput<$PrismaModel>;
	gte?: number | Prisma.IntFieldRefInput<$PrismaModel>;
	not?: Prisma.NestedIntWithAggregatesFilter<$PrismaModel> | number;
	_count?: Prisma.NestedIntFilter<$PrismaModel>;
	_avg?: Prisma.NestedFloatFilter<$PrismaModel>;
	_sum?: Prisma.NestedIntFilter<$PrismaModel>;
	_min?: Prisma.NestedIntFilter<$PrismaModel>;
	_max?: Prisma.NestedIntFilter<$PrismaModel>;
};

export type NestedFloatFilter<$PrismaModel = never> = {
	equals?: number | Prisma.FloatFieldRefInput<$PrismaModel>;
	in?: number[];
	notIn?: number[];
	lt?: number | Prisma.FloatFieldRefInput<$PrismaModel>;
	lte?: number | Prisma.FloatFieldRefInput<$PrismaModel>;
	gt?: number | Prisma.FloatFieldRefInput<$PrismaModel>;
	gte?: number | Prisma.FloatFieldRefInput<$PrismaModel>;
	not?: Prisma.NestedFloatFilter<$PrismaModel> | number;
};

export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
	equals?: string | Prisma.StringFieldRefInput<$PrismaModel>;
	in?: string[];
	notIn?: string[];
	lt?: string | Prisma.StringFieldRefInput<$PrismaModel>;
	lte?: string | Prisma.StringFieldRefInput<$PrismaModel>;
	gt?: string | Prisma.StringFieldRefInput<$PrismaModel>;
	gte?: string | Prisma.StringFieldRefInput<$PrismaModel>;
	contains?: string | Prisma.StringFieldRefInput<$PrismaModel>;
	startsWith?: string | Prisma.StringFieldRefInput<$PrismaModel>;
	endsWith?: string | Prisma.StringFieldRefInput<$PrismaModel>;
	not?: Prisma.NestedStringWithAggregatesFilter<$PrismaModel> | string;
	_count?: Prisma.NestedIntFilter<$PrismaModel>;
	_min?: Prisma.NestedStringFilter<$PrismaModel>;
	_max?: Prisma.NestedStringFilter<$PrismaModel>;
};

export type NestedEnumTitleWithAggregatesFilter<$PrismaModel = never> = {
	equals?: $Enums.Title | Prisma.EnumTitleFieldRefInput<$PrismaModel>;
	in?: $Enums.Title[];
	notIn?: $Enums.Title[];
	not?: Prisma.NestedEnumTitleWithAggregatesFilter<$PrismaModel> | $Enums.Title;
	_count?: Prisma.NestedIntFilter<$PrismaModel>;
	_min?: Prisma.NestedEnumTitleFilter<$PrismaModel>;
	_max?: Prisma.NestedEnumTitleFilter<$PrismaModel>;
};

export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
	equals?: boolean | Prisma.BooleanFieldRefInput<$PrismaModel>;
	not?: Prisma.NestedBoolWithAggregatesFilter<$PrismaModel> | boolean;
	_count?: Prisma.NestedIntFilter<$PrismaModel>;
	_min?: Prisma.NestedBoolFilter<$PrismaModel>;
	_max?: Prisma.NestedBoolFilter<$PrismaModel>;
};

export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
	equals?: Date | string | Prisma.DateTimeFieldRefInput<$PrismaModel>;
	in?: Date[] | string[];
	notIn?: Date[] | string[];
	lt?: Date | string | Prisma.DateTimeFieldRefInput<$PrismaModel>;
	lte?: Date | string | Prisma.DateTimeFieldRefInput<$PrismaModel>;
	gt?: Date | string | Prisma.DateTimeFieldRefInput<$PrismaModel>;
	gte?: Date | string | Prisma.DateTimeFieldRefInput<$PrismaModel>;
	not?: Prisma.NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string;
	_count?: Prisma.NestedIntFilter<$PrismaModel>;
	_min?: Prisma.NestedDateTimeFilter<$PrismaModel>;
	_max?: Prisma.NestedDateTimeFilter<$PrismaModel>;
};

export type NestedEnumTimeClassFilter<$PrismaModel = never> = {
	equals?: $Enums.TimeClass | Prisma.EnumTimeClassFieldRefInput<$PrismaModel>;
	in?: $Enums.TimeClass[];
	notIn?: $Enums.TimeClass[];
	not?: Prisma.NestedEnumTimeClassFilter<$PrismaModel> | $Enums.TimeClass;
};

export type NestedEnumVariantFilter<$PrismaModel = never> = {
	equals?: $Enums.Variant | Prisma.EnumVariantFieldRefInput<$PrismaModel>;
	in?: $Enums.Variant[];
	notIn?: $Enums.Variant[];
	not?: Prisma.NestedEnumVariantFilter<$PrismaModel> | $Enums.Variant;
};

export type NestedEnumResultFilter<$PrismaModel = never> = {
	equals?: $Enums.Result | Prisma.EnumResultFieldRefInput<$PrismaModel>;
	in?: $Enums.Result[];
	notIn?: $Enums.Result[];
	not?: Prisma.NestedEnumResultFilter<$PrismaModel> | $Enums.Result;
};

export type NestedEnumPhraseFilter<$PrismaModel = never> = {
	equals?: $Enums.Phrase | Prisma.EnumPhraseFieldRefInput<$PrismaModel>;
	in?: $Enums.Phrase[];
	notIn?: $Enums.Phrase[];
	not?: Prisma.NestedEnumPhraseFilter<$PrismaModel> | $Enums.Phrase;
};

export type NestedEnumTimeClassWithAggregatesFilter<$PrismaModel = never> = {
	equals?: $Enums.TimeClass | Prisma.EnumTimeClassFieldRefInput<$PrismaModel>;
	in?: $Enums.TimeClass[];
	notIn?: $Enums.TimeClass[];
	not?:
		| Prisma.NestedEnumTimeClassWithAggregatesFilter<$PrismaModel>
		| $Enums.TimeClass;
	_count?: Prisma.NestedIntFilter<$PrismaModel>;
	_min?: Prisma.NestedEnumTimeClassFilter<$PrismaModel>;
	_max?: Prisma.NestedEnumTimeClassFilter<$PrismaModel>;
};

export type NestedEnumVariantWithAggregatesFilter<$PrismaModel = never> = {
	equals?: $Enums.Variant | Prisma.EnumVariantFieldRefInput<$PrismaModel>;
	in?: $Enums.Variant[];
	notIn?: $Enums.Variant[];
	not?:
		| Prisma.NestedEnumVariantWithAggregatesFilter<$PrismaModel>
		| $Enums.Variant;
	_count?: Prisma.NestedIntFilter<$PrismaModel>;
	_min?: Prisma.NestedEnumVariantFilter<$PrismaModel>;
	_max?: Prisma.NestedEnumVariantFilter<$PrismaModel>;
};

export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
	equals?: number | Prisma.FloatFieldRefInput<$PrismaModel>;
	in?: number[];
	notIn?: number[];
	lt?: number | Prisma.FloatFieldRefInput<$PrismaModel>;
	lte?: number | Prisma.FloatFieldRefInput<$PrismaModel>;
	gt?: number | Prisma.FloatFieldRefInput<$PrismaModel>;
	gte?: number | Prisma.FloatFieldRefInput<$PrismaModel>;
	not?: Prisma.NestedFloatWithAggregatesFilter<$PrismaModel> | number;
	_count?: Prisma.NestedIntFilter<$PrismaModel>;
	_avg?: Prisma.NestedFloatFilter<$PrismaModel>;
	_sum?: Prisma.NestedFloatFilter<$PrismaModel>;
	_min?: Prisma.NestedFloatFilter<$PrismaModel>;
	_max?: Prisma.NestedFloatFilter<$PrismaModel>;
};

export type NestedEnumResultWithAggregatesFilter<$PrismaModel = never> = {
	equals?: $Enums.Result | Prisma.EnumResultFieldRefInput<$PrismaModel>;
	in?: $Enums.Result[];
	notIn?: $Enums.Result[];
	not?:
		| Prisma.NestedEnumResultWithAggregatesFilter<$PrismaModel>
		| $Enums.Result;
	_count?: Prisma.NestedIntFilter<$PrismaModel>;
	_min?: Prisma.NestedEnumResultFilter<$PrismaModel>;
	_max?: Prisma.NestedEnumResultFilter<$PrismaModel>;
};

export type NestedEnumPhraseWithAggregatesFilter<$PrismaModel = never> = {
	equals?: $Enums.Phrase | Prisma.EnumPhraseFieldRefInput<$PrismaModel>;
	in?: $Enums.Phrase[];
	notIn?: $Enums.Phrase[];
	not?:
		| Prisma.NestedEnumPhraseWithAggregatesFilter<$PrismaModel>
		| $Enums.Phrase;
	_count?: Prisma.NestedIntFilter<$PrismaModel>;
	_min?: Prisma.NestedEnumPhraseFilter<$PrismaModel>;
	_max?: Prisma.NestedEnumPhraseFilter<$PrismaModel>;
};
